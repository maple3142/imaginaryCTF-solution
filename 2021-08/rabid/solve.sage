from Crypto.Util.number import *
from itertools import product


def nextPrime(x):
    x |= (~x) & 1
    x += 2
    while not isPrime(x):
        x += 2
    return x


n = 3877513957495306793735210462541193869770234003073261648034464894286078655855374755662092117540926052559031362663608669168823731540897355102663189926795117347249504135450639408223984740839141036640828212326855943702095048396466825642695789940319877487298262789308780178511837077996160610919614009819230243290025308355349543068600149755761576412889220166397267858509826675753761043711128750488540393013785228170988297402126780069457874099535370327027270543234623357036976555618221909519099262876294193069328029055427983318375388331685102611299092867609014074761617175400266718535468361295591522343446936027534475164599
c = 30466462700380251910232446456921034678483293377464480881820351526875755951834801625635839596493072554209446857677982349323092200191959770017157555462946499900875610790412503422218809488592493618252748231892352039546011219876624749479629074512623523864509388966263024516088630484962670684054916282393876073225

q = n.nth_root(4, truncate_mode=True)[0]
p = previous_prime(q)
r = next_prime(q)
s = next_prime(r)
assert p * q * r * s == n


def psqrt(c, p):
    assert kronecker(c, p) == 1
    return map(ZZ, GF(p)(c).sqrt(all=True))


for ans in product(*[psqrt(c, p) for p in [p, q, r, s]]):
    m = long_to_bytes(crt(list(ans), [p, q, r, s]))
    if b"ictf" in m:
        print(m)
